# AI Traffic Optimizer â€” Complete System Summary

_This document is a comprehensive summary of the AI Traffic Optimizer app, explaining its architecture, components, external APIs, and custom traffic logic. It is designed to provide full context to any LLM (like ChatGPT) to understand how the system works without having to read the entire codebase._

## 1. Overview & Tech Stack

**AI Traffic Optimizer** is a React Native (Expo SDK 54) mobile app providing real-time traffic-aware navigation, primarily focused on cities in Zimbabwe (e.g., Bulawayo, Harare).
It generates routing paths between the user's live GPS location and a destination, applying a custom **Traffic Prediction Engine** to estimate travel times based on road types, rush hours, weather, and simulated ML heuristics.

**Tech Stack:**

- **Framework:** React Native / Expo
- **Mapping:** Leaflet 1.9.4 rendered inside a `react-native-webview`
- **Routing API:** OSRM (Open Source Routing Machine)
- **Geocoding API:** Nominatim (OpenStreetMap)
- **Weather API:** Open-Meteo
- **Backend/Storage:** Supabase (Auth, Search history persistence) & AsyncStorage (Local cache)
- **Location Services:** `expo-location` (GPS tracking)
- **Network Status:** `@react-native-community/netinfo`

---

## 2. Core Architecture & Data Flow

The user interacts primarily with `App.js`, which orchestrates all core states and the UI stack (Map, Search Bar, Bottom Sheet, etc.).

1. **Input:** User selects an origin/destination via autocomplete (`src/data/locations.json` handles ~190 landmarks) or types a custom location.
2. **Geocoding:** `trafficApi.js` forwards custom unmapped text to Nominatim to get `[lat, lon]`.
3. **Fetching API Data:** `trafficApi.js` fetches OSRM routes and Open-Meteo weather data concurrently.
4. **Processing Paths:** `routeHelpers.js` processes these routes:
   - Evaluates the path through the **Traffic Prediction Engine** (`trafficEngine.js`).
   - Applies the **ML Heuristic Scoring** (`mlOptimization.js`).
   - Limits or cushions to exactly 3 route choices (clones/pads if OSRM gives < 3).
5. **Rendering UI:** `App.js` updates state. The selected route's parsed GeoJSONâ€”split into colored segments based on congestionâ€”is injected back into the Leaflet WebView map via `webViewRef.current.injectJavaScript()`.
6. **Data Persistence:** The destination query and routing statistics are background-saved to Supabase recent searches history.

---

## 3. The Custom Traffic Prediction Engine (`trafficEngine.js`)

Since there's no real-time traffic feed (like Waze/Google Maps provide via closed API), the app mathematically calculates delays utilizing contextual flags:

1. **Road Classification:** Base speed from OSRM dictates road type (`HIGHWAY` > 80km/h, `MAIN_ROAD` > 50km/h, `LOCAL_ROAD` > 30km/h, `NARROW_ROAD` <= 30km/h).
2. **Time Factor:** Uses hardcoded curves for Weekdays vs. Weekends. City traffic peaks are simulated between 7-9 AM and 4-6:30 PM. Fridays have a special evening traffic boost.
3. **Weather Factor:** Uses Open-Meteo current condition codes (Clear, Drizzle, Rain, Storm). Weather impact scales dynamically based on road type. E.g., storms on narrow dirt roads cripple speed by 60%, while highways only drop 30%.
4. **Congestion Resistance:** Highways slow down less per "traffic capacity unit" than local roads. Random bottlenecks (5% chance) or accidents (2% chance) are simulated during high-traffic intervals to recreate dynamic city driving environments.
5. **Proportional Scaling & UI Colors:**
   - A critical hardcoded requirement enforces a 7-minute baseline duration for a 6.6km baseline route (NUST to City Hall). All generated routes leverage proportional scaling based on base vs. predicted speeds to maintain this UI logic globally.
   - Ratios between `predictedSpeed` and `baseSpeed` determine route segment colors: Green (Clear, >=80%), Yellow (Moderate, 50-80%), Red (Heavy, <50%).

---

## 4. Route Processing & ML Heuristics (`routeHelpers.js` & `mlOptimization.js`)

- **Route Options & Comparisons:** The app evaluates the available paths, labels them `BEST`, `ALT`, and `SLOW`, and runs the segment speeds at different future time offsets to provide "future" predictions (`Now`, `+15 min`, `+30 min`).
- **ML Optimization Module (`mlOptimization.js`):** Intercepts original heuristic scores generated by the engine.
  - Evaluates routes against historical weights cached in `AsyncStorage`.
  - Mimics a "learning" model that updates historical multipliers via exponential moving average based on user route feedback to adjust the confidence score.
  - Applies hardcoded edge-case fallbacks to penalize known traffic traps (e.g., Masiyephambili Drive or Leopold Takawira Avenue).

---

## 5. UI & Components Breakdown

- **`App.js`:** The React Native root. Holds states for coordinates, GPS subscriptions, routing states. Authenticate walls the application via `AuthGate` & `AuthContext`.
- **`MapLayer.js` & `mapHtml.js`:** Wraps the Leaflet map in a React Native WebView. Handles 5 customizable map Tile Layers (Satellite, Midnight Commander, Streets etc). Serves JS injection hooks `initMap()`, `setUserLocation()`, and `drawRoute()`.
- **`RoutePlanner.js` & `SearchBar.js`:** Floating modular top inputs resolving names into coordinates, integrated with Supabase cache for quick access to "Recent Searches".
- **`RouteBottomSheet.js`:** Animated expanded bottom sheet displaying ETA comparisons between routes, predictions over +15 / +30 mins, and road conditions mapping.
- **`NetworkStatus.js` & `WeatherWidget.js`:** Floating status overlays showing offline disconnections and current Open-Meteo weather codes dynamically mapped to UI Icons.
- **`RoadConditionsPanel.js`:** Breaks down the selected route explicitly displaying individual step-by-step road delay impact lists.

---

## 6. End-to-End User Experience & Interaction Flow

To fully understand the system, here is an exhaustive step-by-step breakdown of how an end user expects to interact with the application when planning a trip.

### Step 1: App Launch & Initial State

- **On Launch:** The user opens the app and is greeted by a full-screen, responsive Leaflet map focused on their last known location or a default coordinate.
- **GPS Acquisition:** The app immediately requests location permissions (if not already granted). Upon success, the `Location.watchPositionAsync` listener starts tracking the user's live GPS coordinates.
- **Visual Feedback:** A blue circle marker (`#007AFF`) appears on the map, accurately reflecting the user's real-time position. The map automatically pans to this position.

### Step 2: Entering Search Queries (The Floating Search Bar)

- **The Search Bar:** At the top of the screen floats a white, pill-shaped `SearchBar.js` component. It contains two inputs: **Origin** (defaulting to "My Location") and **Destination**.
- **Typing & Autocomplete:** As the user types into either field, the app actively filters against a local JSON file (`src/data/locations.json` containing ~190 landmarks in Zimbabwe).
- **Dropdown Suggestions:** After 3 characters, a dropdown of smart autocomplete suggestions appears.
- **Selection:**
  - If the user taps a suggestion, the app instantly locks in the exact pre-defined `[lat, lon]` coordinates.
  - If the user ignores the suggestions and types a custom address (e.g., "123 Fife Street"), they can hit "Search".
- **Reverse/Swap Flow:** A swap button allows the user to quickly flip their origin and destination.

### Step 3: Resolving the Route & The Loading State

- **Search Execution:** When the user initiates the search, a full-screen `LoadingOverlay.js` (a shimmering/pulsing animation) appears, locking the UI from further input.
- **Geocoding (Nominatim):** If the user typed a custom address not found in the local `locations.json`, the app quietly makes a background API call to Nominatim OpenStreetMap (`trafficApi.js`) to convert that text string into GPS coordinates.
- **Fetching Routes (OSRM):** The app then pings the Open Source Routing Machine (OSRM) with the Start and End coordinates, requesting alternative routes (`alternatives=true`).
- **Fetching Weather (Open-Meteo):** Concurrently, the app fetches live localized weather data for the destination.

### Step 4: The Analysis & "Brain" Processing (Background)

While the loading screen is still spinning, the core systems analyze the raw OSRM data:

- `routeHelpers.js` guarantees exactly 3 routes exist. If OSRM only found 1 or 2, the app creates simulated "alternative" paths to ensure the user always has choices.
- `trafficEngine.js` breaks down every single road segment (leg/step) of each route. It looks at the current time (`getTimeTrafficFactor`), the weather (`getWeatherImpact`), and the inferred road type (`classifyRoad`).
- It applies mathematical penalties. For example, if it's 5:00 PM on a Friday (Peak Hour) and the weather API reports a thunderstorm, the engine drastically reduces the calculated travel speed on narrow roads, but less so on highways.
- **ML Scoring:** `mlOptimization.js` cross-references the routes against historically saved route patterns and applies subtle heuristic score multipliers.
- **Final Output:** The engine ranks the 3 routes (BEST, ALT, SLOW), assigns UI colors (Green, Yellow, Red), and generates human-readable reasons (e.g., "Clear Road", "Moderate Traffic", "Heavy Traffic & Rain").

### Step 5: The Map Updates & Route Display

- **Loading Clears:** The loading overlay vanishes.
- **Map Redraw:** The Leaflet map updates instantly. The camera bounds adjust to frame the entire journey from start to finish (marked by a ðŸ flag emoji).
- **Segmented Route Drawing:** The "BEST" route is drawn on the map. It is not necessarily one solid color; the polyline is drawn in "segments" (Green, Yellow, Red) representing calculated bottlenecks along the specific roads on that path.
- **Weather Widget:** A floating weather badge (`WeatherWidget.js`) appears showing the current temperature and an icon representing the live weather at the destination (e.g., a rain cloud).

### Step 6: The Route Bottom Sheet (Comparison & Selection)

- **The Persistent Sheet:** A `RouteBottomSheet.js` slides up from the bottom of the screen.
- **Collapsed View (The Header):** By default, it shows the "BEST" route. The user sees a massive, clear ETA (e.g., "12 min"), the distance (e.g., "4.2 km"), the color-coded label ("BEST"), and the AI-generated reason ("Clear Road").
- **Time Travel / Prediction Tabs:** At the top of the sheet are tabs: `"Now"`, `"+15 min"`, `"+30 min"`. If the user taps `+30 min`, the entire UI updates. The ETA might unexpectedly jump from 12 mins to 25 mins, and the route color might change from Green to Red because the app knows rush hour begins in 30 minutes.
- **Expanding the Sheet:** The user swipes up or taps the chevron to expand the sheet.
- **Alternative Routes List:** Expanded, they see the list of all 3 routes (BEST, ALT, SLOW) stacked vertically for easy comparison. They can tap any of these alternative cards.
- **Interactivity:** Tapping an alternative route card instantly redraws the map to show that new path and updates the sheet header to reflect the newly selected route's ETA and traffic reasoning.

### Step 7: Granular Road Conditions (The Deep Dive)

- **Road Conditions Panel:** Below the alternative routes list in the expanded sheet, there is a detailed `RoadConditionsPanel.js`.
- **Step-by-Step Breakdown:** This panel lists specific road segments that make up the active route (e.g., "Cecil Avenue", "Gwanda Road").
- **Delay Diagnostics:** Next to each road name, it shows the user the exact predicted delay in minutes (e.g., "+3.2 mins delay"), the predicted speed vs base speed, and a colored severity indicator. If there is a simulated incident, it might even say "Bottleneck Delay". This gives the user total transparency into exactly _where_ the AI expects the traffic to be worst on their chosen trip.

### Step 8: Execution & Tracking

- **Search Memory:** The app silently saves this successful search to Superbase (if logged in) and local AsyncStorage. The next time the user taps the destination box, this location will appear instantly as a quick-select chip in their "Recent Searches".
- **Live Location:** As the user begins driving, their blue GPS dot physically moves along the drawn route on the map in real-time, thanks to the continuous `watchPositionAsync` listener running in the background. If they pan away, they can tap the "Locate Me" FAB to perfectly re-center the camera on their moving car.
